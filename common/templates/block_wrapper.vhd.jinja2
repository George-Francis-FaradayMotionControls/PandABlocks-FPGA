--------------------------------------------------------------------------------
-- Top-level VHDL wrapper for a block
-- This is responsible for creating {{ number }} instances of a {{ name }} Block
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.top_defines.all;


entity {{ entity }}_wrapper is
generic (
    NUM : natural := {{ number }}
);
port (
    -- Clocks and Resets
    clk_i               : in  std_logic := '0';
    reset_i             : in  std_logic := '0';

    -- Bus inputs
    -- TODO: rename to bit_bus_i
    bit_bus_i           : in  sysbus_t := (others => '0');
    pos_bus_i           : in  posbus_t := (others => (others => '0'));

    -- Bus outputs
{% for field in filter_fields("bit_out") %}
    {{ field.name }}_o  : out std_logic_vector(NUM-1 downto 0);
{% endfor %}
{% for field in filter_fields("pos_out") %}
    {{ field.name }}_o  : out std32_array(NUM-1 downto 0);
{% endfor %}

    -- Memory Interface
    read_strobe_i       : in  std_logic := '0';
    read_address_i      : in  std_logic_vector(PAGE_AW-1 downto 0) := (others => '0');
    read_data_o         : out std_logic_vector(31 downto 0);
    read_ack_o          : out std_logic;

    write_strobe_i      : in  std_logic := '0';
    write_address_i     : in  std_logic_vector(PAGE_AW-1 downto 0) := (others => '0');
    write_data_i        : in  std_logic_vector(31 downto 0) := (others => '0');
    write_ack_o         : out std_logic
);
end {{ entity }}_wrapper;

architecture rtl of {{ entity }}_wrapper is


-- Register addresses, current values and strobes, an array of these for NUM
-- Blocks

{% for field in fields %}
    {% if field.type in "time" %}
signal {{ field.name }}          : std48_array(NUM-1 downto 0);

    {% endif %}
    {% for register in field.registers %}
constant {{ register.name }}_addr : natural := {{ register.number }};
signal {{ register.name }}        : std32_array(NUM-1 downto 0);
signal {{ register.name }}_wstb   : std_logic_vector(NUM-1 downto 0);

    {% endfor %}
{% endfor %}

-- Current values for bit muxes

{% for field in filter_fields("bit_mux") %}
signal {{ field.name }}_from_bus : std_logic_vector(NUM-1 downto 0);
{% endfor %}


-- Register interface common

signal read_strobe      : std_logic_vector(NUM-1 downto 0);
signal read_data        : std32_array(NUM-1 downto 0);
signal write_strobe     : std_logic_vector(NUM-1 downto 0);
signal read_addr        : natural range 0 to (2**read_address_i'length - 1);
signal write_addr       : natural range 0 to (2**write_address_i'length - 1);


begin

    -- Acknowledgement to AXI Lite interface
    write_ack_o <= '1';

    read_ack_delay : entity work.delay_line
    generic map (DW => 1)
    port map (
        clk_i       => clk_i,
        data_i(0)   => read_strobe_i,
        data_o(0)   => read_ack_o,
        DELAY       => RD_ADDR2ACK
    );

    -- Generate NUM instances of the blocks
    GEN : FOR I IN 0 TO (NUM-1) GENERATE

        -- Sub-module address decoding
        read_strobe(I) <= compute_block_strobe(read_address_i, I) and read_strobe_i;
        write_strobe(I) <= compute_block_strobe(write_address_i, I) and write_strobe_i;
        read_addr <= to_integer(unsigned(read_address_i(BLK_AW-1 downto 0)));
        write_addr <= to_integer(unsigned(write_address_i(BLK_AW-1 downto 0)));

        -- Control System Register Interface
        REG_WRITE : process(clk_i)
        begin
            if rising_edge(clk_i) then
                -- Zero all the write strobe arrays, we set them below
{% for field in fields %}
    {% for register in field.registers %}
                {{ register.name }}_wstb(I) <= '0';
    {% endfor %}
{% endfor %}
                if (write_strobe(I) = '1') then
                    -- Set the specific write strobe that has come in
                    case write_addr is
{% for field in fields %}
    {% for register in field.registers %}
                        when {{ register.name }}_addr =>
                            {{ register.name }}(I) <= write_data_i;
                            {{ register.name }}_wstb(I) <= '1';
    {% endfor %}
{% endfor %}
                        when others =>
                            null;
                    end case;
                end if;
            end if;
        end process;

        --
        -- Status Register Read     // NOT dealt with yet!      -- Need MUX for read_data(I)
                                                                -- find examples that actually have register reads...
        --
        REG_READ : process(clk_i)
        begin
            if rising_edge(clk_i) then
                case (read_addr) is
                    when others =>
                        read_data(I) <= (others => '0');
                end case;
            end if;
        end process;

        -- Instantiate Delay Blocks for Bit and Position Bus Fields
{% for field in filter_fields("bit_mux") %}
        bitmux_{{ field.name }} : entity work.bitmux
        port map (
            clk_i       => clk_i,
            sysbus_i    => bit_bus_i,
            bit_o       => {{ field.name }}_from_bus(I),
            bitmux_sel  => {{ field.name }}(I),
            bit_dly     => {{ field.name }}_DLY(I)
        );

{% endfor %}
{% for field in filter_fields("pos_mux") %}
        posmux_{{ field.name }} : entity work.posmux
        port map (
            clk_i       => clk_i,
            posbus_i    => pos_bus_i,
            posn_o      => {{ field.name }}_from_bus(I),
            posmux_sel  => {{ field.name }}(I),
            pos_dly     => {{ field.name }}_DLY(I)
        );

{% endfor %}

{% for field in filter_fields("time") %}
    {% if loop.first %}
        -- Time signals are made up of _L and _H parts
    {% endif %}
        {{ field.name }}(I) <= (47 downto 32 => {{field.name}}_H(I)(15 downto 0),
                     31 downto 0 => {{field.name}}_L(I));

{% endfor %}

        -- Connect to the actual logic entity
        {{ entity }} : entity work.{{ entity }}
        port map (
{% for field in filter_fields(".*_mux") %}
            {{ field.name }}_i => {{ field.name }}_from_bus(I),
{% endfor %}
{% for field in filter_fields("time|param lut|param int|param time|param") %}
            {{ field.name }} => {{ field.name }}(I),
{% endfor %}
{% for field in filter_fields("write int|read uint 1023|read") %}
            {{ field.name }} => {{ field.name }}(I),
{% endfor %}
{% for field in filter_fields("param bit|write action" )%}
            {{ field.name }} => {{ field.name }}(I)(0),
{% endfor %}
{% for field in filter_fields("param enum|read enum") %}
            {{ field.name }} => {{ field.name }}(I)(1 downto 0),
{% endfor %}
{% for field in filter_fields(".*_out") %}
            {{ field.name }}_o => {{ field.name }}_o(I),
{% endfor %}
{% for field in fields %}
    {% if field.wstb %}
            {{ field.name }}_wstb => {{ field.name }}_wstb(I),
    {% endif %}
{% endfor %}
            clk_i => clk_i
        );

    END GENERATE;

end rtl;

