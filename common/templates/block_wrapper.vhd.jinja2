-- AUTOGENERATED
--------------------------------------------------------------------------------
-- Top-level VHDL wrapper for a block
-- This is responsible for creating {{ number }} instances of a {{ name }} Block
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.top_defines.all;


entity {{ entity }}_wrapper is
generic (
    NUM : natural := {{ number }}
);
port (
    -- Clocks and Resets
    clk_i               : in  std_logic := '0';
    reset_i             : in  std_logic := '0';

    -- Bus inputs
    -- TODO: rename to bit_bus_i
    bit_bus_i           : in  sysbus_t := (others => '0');
    pos_bus_i           : in  posbus_t := (others => (others => '0'));

    -- Bus outputs
{% for field in filter_fields("bit_out") %}
    {{ "%-20s"| format(field.name + "_o") }}: out std_logic_vector(NUM-1 downto 0);
{% endfor %}
{% for field in filter_fields("pos_out") %}
    {{ "%-20s"| format(field.name + "_o") }}: out std32_array(NUM-1 downto 0);
{% endfor %}

{% if type == "dma" %}
    -- DMA signals
    dma_req_o           : out std_logic_vector({{ number-1 }} downto 0);
    dma_ack_i           : in  std_logic_vector({{ number-1 }} downto 0);
    dma_done_i          : in  std_logic;
    dma_addr_o          : out std32_array({{ number-1 }} downto 0);
    dma_len_o           : out std8_array({{ number-1 }} downto 0);
    dma_data_i          : in  std_logic_vector(31 downto 0);
    dma_valid_i         : in  std_logic_vector({{ number-1 }} downto 0);
{% endif %}
    -- Memory Interface
    read_strobe_i       : in  std_logic := '0';
    read_address_i      : in  std_logic_vector(PAGE_AW-1 downto 0) := (others => '0');
    read_data_o         : out std_logic_vector(31 downto 0);
    read_ack_o          : out std_logic;

    write_strobe_i      : in  std_logic := '0';
    write_address_i     : in  std_logic_vector(PAGE_AW-1 downto 0) := (others => '0');
    write_data_i        : in  std_logic_vector(31 downto 0) := (others => '0');
    write_ack_o         : out std_logic
);
end {{ entity }}_wrapper;

architecture rtl of {{ entity }}_wrapper is


-- Register addresses, current values and strobes, an array of these for NUM
-- Blocks

{% for field in fields %}
    {% if field.type in "time" %}
{# Time signals are 48 bits so require two registers for reading their data. #}
signal {{ field.name }}            : std64_array(NUM-1 downto 0);
signal {{ field.name }}_wstb       : std_logic_vector(NUM-1 downto 0);
signal {{ field.name }}_L_wstb     : std_logic_vector(NUM-1 downto 0);
signal {{ field.name }}_H_wstb     : std_logic_vector(NUM-1 downto 0);

    {% else %}
        {% for register in field.registers %}
            {% if register.number >= 0 %}
signal {{ register.name }}        : std32_array(NUM-1 downto 0);
signal {{ register.name }}_wstb   : std_logic_vector(NUM-1 downto 0);

            {% endif %}
        {% endfor %}
    {% endif %}
{% endfor %}

-- Register interface common

signal read_strobe      : std_logic_vector(NUM-1 downto 0);
signal read_data        : std32_array(NUM-1 downto 0);
signal write_strobe     : std_logic_vector(NUM-1 downto 0);
signal read_addr        : natural range 0 to (2**read_address_i'length - 1);
signal write_addr       : natural range 0 to (2**write_address_i'length - 1);


begin

    -- Acknowledgement to AXI Lite interface
    write_ack_o <= '1';

    read_ack_delay : entity work.delay_line
    generic map (DW => 1)
    port map (
        clk_i       => clk_i,
        data_i(0)   => read_strobe_i,
        data_o(0)   => read_ack_o,
        DELAY       => RD_ADDR2ACK
    );

    read_data_o <= read_data(to_integer(unsigned(read_address_i(PAGE_AW-1 downto BLK_AW))));

    -- Generate NUM instances of the blocks
    GEN : FOR I IN 0 TO (NUM-1) GENERATE

        -- Sub-module address decoding
        read_strobe(I) <= compute_block_strobe(read_address_i, I) and read_strobe_i;
        write_strobe(I) <= compute_block_strobe(write_address_i, I) and write_strobe_i;

        {{ entity }}_ctrl : entity work.{{ entity }}_ctrl
        port map (
            clk_i               => clk_i,
            reset_i             => reset_i,
            bit_bus_i           => bit_bus_i,
            pos_bus_i           => pos_bus_i,

{% for field in fields %}
    {% if field in filter_fields("(param|write).*") %}
        {% for register in field.registers %}
            {% if register.number >= 0 %}
            {{ "%-20s"|format(register.name) }}=> {{ register.name }}(I),
            {{ "%-20s"|format(register.name + "_wstb") }}=> {{ register.name }}_wstb(I),
            {% endif %}
        {% endfor %}
    {% elif field in filter_fields("table short") %}
            {{ "%-20s"|format(field.name + "_START") }}=> open,
            {{ "%-20s"|format(field.name + "_DATA") }}=> {{ field.name }}_DATA(I),
            {{ "%-20s"|format(field.name + "_LENGTH") }}=> {{ field.name }}_LENGTH(I),
            {{ "%-20s"|format(field.name + "_START_wstb") }}=> {{ field.name }}_START(I)(0),
            {{ "%-20s"|format(field.name + "_DATA_wstb") }}=> {{ field.name }}_DATA_wstb(I),
            {{ "%-20s"|format(field.name + "_LENGTH_wstb") }}=> {{ field.name }}_LENGTH_wstb(I),
    {% elif field in filter_fields("time") %}
            {{ "%-20s"|format(field.name + "_L") }}=> {{ field.name }}(I)(31 downto 0),
            {{ "%-20s"|format(field.name + "_H") }}=> {{ field.name }}(I)(63 downto 32),
            {{ "%-20s"|format(field.name + "_L_wstb") }}=> {{ field.name }}_L_wstb(I),
            {{ "%-20s"|format(field.name + "_H_wstb") }}=> {{ field.name }}_H_wstb(I),
    {% elif field in filter_fields("read.*") %}
            {{ "%-20s"|format(field.name) }}=> {{field.name }}(I),
    {% elif field in filter_fields("bit_mux") %}
            {{ "%-20s"|format(field.name+"_from_bus") }}=> {{ field.name }}(I)(0),
    {% elif field in filter_fields("pos_mux") %}
            {{ "%-20s"|format(field.name+"_from_bus") }}=> {{ field.name }}(I),
    {% endif %}
{% endfor %}

            read_strobe_i       => read_strobe(I),
            read_address_i      => read_address_i(BLK_AW-1 downto 0),
            read_data_o         => read_data(I),
            read_ack_o          => open,

            write_strobe_i      => write_strobe(I),
            write_address_i     => write_address_i(BLK_AW-1 downto 0),
            write_data_i        => write_data_i,
            write_ack_o         => open
        );

{% for field in filter_fields("time") %}
    {% if loop.first %}
        -- Time signals are made up of _L and _H parts and the overall 
        -- signal wstb is the or output of the two
    {% endif %}
        {{ field.name }}_wstb(I) <= {{ field.name }}_L_wstb(I) or {{ field.name }}_H_wstb(I);

{% endfor %}
        -- Connect to the actual logic entity
        {{ entity }} : entity work.{{ entity }}
        port map (
{% for field in filter_fields("bit_mux") %}
            {{ "%-20s"|format(field.name +"_i") }}=> {{ field.name }}(I)(0),
{% endfor %}
{% for field in filter_fields("pos_mux") %}
            {{ "%-20s"|format(field.name +"_i") }}=> {{ field.name }}(I),
{% endfor %}
{# Filter_fields requires both param and read to be the last type in the list #}
{% for field in filter_fields("param lut|param int|param time|param") %}
            {{ "%-20s"|format(field.name) }}=> {{ field.name }}(I),
{% endfor %}
{% for field in filter_fields("time") %}
            {{ "%-20s"|format(field.name) }}=> {{ field.name }}(I)(47 downto 0),
{% endfor %}
{% for field in filter_fields("table short") %}
            {{ "%-20s"|format(field.name + "_START") }}=> {{ field.name}}_START(I)(0),
            {{ "%-20s"|format(field.name + "_DATA") }}=> {{ field.name}}_DATA(I),
            {{ "%-20s"|format(field.name + "_LENGTH") }}=> {{ field.name}}_LENGTH(I),
{% endfor %}
{# Filter_fields requires both param and read to be the last type in the list #}
{% for field in filter_fields("write int|read uint 1023|read") %}
            {{ "%-20s"|format(field.name) }}=> {{ field.name }}(I),
{% endfor %}
{% for field in filter_fields("param bit|write action" )%}
            {{ "%-20s"|format(field.name) }}=> {{ field.name }}(I)(0),
{% endfor %}
{% for field in filter_fields("param enum|read enum") %}
            {{ "%-20s"|format(field.name) }}=> {{ field.name }}(I)({{field.enumlength}} downto 0),
{% endfor %}
{% for field in filter_fields(".*_out") %}
            {{ "%-20s"|format(field.name + "_o") }}=> {{ field.name }}_o(I),
{% endfor %}
{% for field in fields %}
    {% if field.wstb %}
        {% if "table" in field.type %}
            {{ "%-20s"|format(field.name + "_LENGTH_wstb") }}=> {{ field.name }}_LENGTH_wstb(I),
            {% if "short" in field.type %}
            {{ "%-20s"|format(field.name + "_wstb") }}=> {{ field.name }}_DATA_wstb(I),
            {% endif %}
        {% else %}
            {{ "%-20s"|format(field.name + "_wstb") }}=> {{ field.name }}_wstb(I),
        {% endif %}
    {% endif %}
{% endfor %}
{% if type == "dma" %}
            dma_req_o           => dma_req_o(I),
            dma_ack_i           => dma_ack_i(I),
            dma_done_i          => dma_done_i,
            dma_addr_o          => dma_addr_o(I),
            dma_len_o           => dma_len_o(I),
            dma_data_i          => dma_data_i,
            dma_valid_i         => dma_valid_i(I),
{% endif %}
            clk_i               => clk_i
        );

    END GENERATE;

end rtl;

